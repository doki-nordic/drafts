const { createHash } = require('crypto');

const HEADER = exports.HEADER = 'header';
const FOOTER = exports.HEADER = 'footer';
const BEGIN = exports.BEGIN = 'begin';
const LOCALS = exports.LOCALS = 'locals';
const ALLOCATE = exports.ALLOCATE = 'allocate';
const ENCODE_PARAMS = exports.ENCODE_PARAMS = 'encode';
const SEND = exports.SEND = 'send';
const RETURN = exports.RETURN = 'return';
const INVALID = exports.INVALID = 'invalid';


const numberToName = {
	[6]: HEADER,
	[0]: BEGIN,
	[1]: LOCALS,
	[2]: ALLOCATE,
	[3]: ENCODE_PARAMS,
	[4]: SEND,
	[5]: RETURN,
	[7]: FOOTER,
	[255]: INVALID
}


const nameToNumber = {};
for (let x in numberToName){
	nameToNumber[numberToName[x]] = x;
}


function codeChecksum(code) {
	code = code
		.replace(/\/\*.*?\*\/|\/\/.*?(?=\n)/g, ' ')
		.replace(/[\x00- ]+/g, ' ')
		.replace(/(?<=[^a-z0-9_\$]) /gi, '')
		.replace(/ (?=[^a-z0-9_\$])/gi, '')
		.trim();
	const hash = createHash('sha256');
	hash.update(code);
	let buf = hash.digest('buffer');
	return buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
}


function parseSideData(sideData) {
	let buf = Buffer.from(sideData, 'base64');
	return {
		type: numberToName[buf[0]],
		crc: buf[1] | (buf[2] << 8) | (buf[3] << 16) | (buf[4] << 24)
	};
}


function createSideData(type, crc) {
	let buf = Buffer.from([
		nameToNumber[type],
		crc & 0xFF,
		(crc >> 8) & 0xFF,
		(crc >> 16) & 0xFF,
		(crc >> 24) & 0xFF
	]);
	return buf.toString('base64').substr(0, 7);
}


function validate(code, sideData) {
	let crc = codeChecksum(code);
	let info = parseSideData(sideData);
	if (info.crc != crc || info.type === undefined) {
		throw Error(`Side data of autogenerated code is invalid. Expected '${createSideData(info.type || INVALID, crc)}', Current '${sideData}'`);
	}
	return info.type;
}


exports.numberToName = numberToName;
exports.nameToNumber = nameToNumber;
exports.codeChecksum = codeChecksum;
exports.parseSideData = parseSideData;
exports.createSideData = createSideData;
exports.validate = validate;

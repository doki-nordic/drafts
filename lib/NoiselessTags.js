
const CodeBlocks = require('./CodeBlocks');

function extract(functionBody, firstBlock) {

	const MANUAL = 'm';
	const AUTOGENERATED = 'a';
	const BEGIN = '%';
	const CONTINUE = undefined;
	const END = '@';

	let lines = functionBody.split(/(?<=\n)/);
	let currentBlock = firstBlock;
	let state = MANUAL;
	let data = '';
	let result = {};
	let autoCode = '';

	result[currentBlock] = result[currentBlock] || '';

	for (line of lines) {
		let [ending, type, codePart] = line.match(/\/\*##+(%|@)?([A-Za-z0-9\+\/]*)\*\/\s*$/) || ['', MANUAL, null];
		let plainLine = line.substring(0, line.length - ending.length);
		switch (type) {
			case MANUAL:
				if (state != MANUAL) {
					throw Error('Deleted or corrupted end of autogenerated code.');
				}
				result[currentBlock] += line;
				break;
			case BEGIN:
				if (state != MANUAL) {
					throw Error('Deleted or corrupted end of autogenerated code.');
				}
				autoCode = plainLine;
				data = codePart;
				state = AUTOGENERATED;
				break;
			case CONTINUE:
				if (state == MANUAL) {
					autoCode = '';
					data = '';
					state = AUTOGENERATED;
				} else {
					autoCode += plainLine;
					data += codePart;
					break;
				} // break - conditionally inside 'if' body
			case END:
				if (state == MANUAL) {
					throw Error('Deleted or corrupted beginning of autogenerated code.');
				}
				autoCode += plainLine;
				data += codePart;
				currentBlock = CodeBlocks.validate(autoCode, data);
				result[currentBlock] = result[currentBlock] || '';
				state = MANUAL;
				break;
		}
	}

	if (state != MANUAL) {
		throw Error('Deleted or corrupted end of autogenerated code.');
	}

	for (let k of Object.keys(result)) {
		result[k] = result[k]
			.replace(/^([\t \r]*\n)+/, '')
			.replace(/(?<=\n)[\t \r]*(\n[\t \r]*)+$/, '');
		if (result[k] == '') {
			delete result[k];
		}
	}

	return result;
}


function normalizeGenBlock(block)
{
	let code = '';
	let lines = block.trim().split(/\r?\n/g);
	let maxLen = 0;
	for (let line of lines) {
		line = line.trim();
		if (line == '') continue;
		code += `\t${line}\n`;
		maxLen = Math.max(maxLen, 1 + line.length);
	}
	return [code, maxLen];
}

function normalizeUserBlock(block)
{
	let code = '';
	let lines = block.split(/\r?\n/g);
	while (lines.length > 0 && lines[0].trim() == '') {
		lines.shift();
	}
	while (lines.length > 0 && lines[lines.length - 1].trim() == '') {
		lines.pop();
	}
	for (let line of lines) {
		line = line.replace(/\s+$/, '');
		code += `${line}\n`;
	}
	return code;
}

function addSideData(type, block, maxLineLength)
{
	let sideData = CodeBlocks.createSideData(type, CodeBlocks.codeChecksum(block));
	let lines = 0;
	block.replace(/\n/g, () => { lines++;} );
	let sideList;
	if (lines == 1) {
		sideList = [`/*##${sideData}*/`];
	} else {
		let sideDataLen = sideData.length;
		sideData = `%${sideData}`;
		sideList = [];
		for (let i = 0; i < lines; i++) {
			let part;
			if (i < lines - 1) {
				part = sideData.substr(0, Math.ceil((sideData.length + 1) / (lines - i)));
			} else {
				part = '@' + sideData;
			}
			sideData = sideData.substr(part.length);
			part = '################' + part;
			sideList.push(`/*##${part.substr(part.length - sideDataLen)}*/`);
		}
	}
	let i = 0;
	block = block.replace(/(?<=^|\n)(.*?)\n/g, (_, line) => {
		let spaces = maxLineLength - line.length + 1;
		return line + ' '.repeat(spaces) + sideList[i++] + '\n';
	});

	return block;
}

function generate(genBlocks, userBlocks)
{
	let output = '';
	let maxLineLength = 81;
	genBlocks = Object.assign({}, genBlocks);
	userBlocks = Object.assign({}, userBlocks);

	// TODO: Normalization may be moved to CodeBlocks.
	for (let i in genBlocks) {
		let len;
		if (genBlocks[i].trim() == '') {
			genBlocks[i] = `/* Empty '${i}' block */`;
		}
		[genBlocks[i], len] = normalizeGenBlock(genBlocks[i]);
		maxLineLength = Math.max(maxLineLength, len);
	}

	for (let i in userBlocks) {
		userBlocks[i] = normalizeUserBlock(userBlocks[i]);
	}

	for (let num in CodeBlocks.numberToName) {
		let name = CodeBlocks.numberToName[num];
		if (name in genBlocks) {
			output += addSideData(name, genBlocks[name], maxLineLength);
			output += '\n';
		}
		if (name in userBlocks) {
			output += userBlocks[name];
			output += '\n';
		}
	}

	output = output.replace(/\n+$/, '\n');

	return output;
}


exports.extract = extract;
exports.generate = generate;
